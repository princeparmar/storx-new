// AUTOGENERATED BY private/apigen
// DO NOT EDIT.

package example

import (
	"context"
	"encoding/json"
	"net/http"
	"time"

	"github.com/gorilla/mux"
	"github.com/spacemonkeygo/monkit/v3"
	"github.com/zeebo/errs"
	"go.uber.org/zap"

	"storj.io/common/uuid"
	"storj.io/storj/private/api"
	"storj.io/storj/private/apigen/example/myapi"
)

const dateLayout = "2006-01-02T15:04:05.999Z"

var ErrDocsAPI = errs.Class("example docs api")
var ErrUsersAPI = errs.Class("example users api")
var ErrProjectsAPI = errs.Class("example projects api")

type DocumentsService interface {
	Get(ctx context.Context) ([]myapi.Document, api.HTTPError)
	GetOne(ctx context.Context, path string) (*myapi.Document, api.HTTPError)
	GetTag(ctx context.Context, path, tagName string) (*[2]string, api.HTTPError)
	GetVersions(ctx context.Context, path string) ([]myapi.Version, api.HTTPError)
	UpdateContent(ctx context.Context, path string, id uuid.UUID, date time.Time, request myapi.NewDocument) (*myapi.Document, api.HTTPError)
}

type UsersService interface {
	Get(ctx context.Context) ([]myapi.User, api.HTTPError)
	Create(ctx context.Context, request []myapi.User) api.HTTPError
	GetAge(ctx context.Context) (*myapi.UserAge[int16], api.HTTPError)
}

type ProjectsService interface {
	CreateProject(ctx context.Context, request Project) (*Project, api.HTTPError)
}

// DocumentsHandler is an api handler that implements all Documents API endpoints functionality.
type DocumentsHandler struct {
	log     *zap.Logger
	mon     *monkit.Scope
	service DocumentsService
	auth    api.Auth
}

// UsersHandler is an api handler that implements all Users API endpoints functionality.
type UsersHandler struct {
	log     *zap.Logger
	mon     *monkit.Scope
	service UsersService
}

// ProjectsHandler is an api handler that implements all Projects API endpoints functionality.
type ProjectsHandler struct {
	log     *zap.Logger
	mon     *monkit.Scope
	service ProjectsService
}

func NewDocuments(log *zap.Logger, mon *monkit.Scope, service DocumentsService, router *mux.Router, auth api.Auth) *DocumentsHandler {
	handler := &DocumentsHandler{
		log:     log,
		mon:     mon,
		service: service,
		auth:    auth,
	}

	docsRouter := router.PathPrefix("/api/v0/docs").Subrouter()
	docsRouter.HandleFunc("/", handler.handleGet).Methods("GET")
	docsRouter.HandleFunc("/{path}", handler.handleGetOne).Methods("GET")
	docsRouter.HandleFunc("/{path}/tag/{tagName}", handler.handleGetTag).Methods("GET")
	docsRouter.HandleFunc("/{path}/versions", handler.handleGetVersions).Methods("GET")
	docsRouter.HandleFunc("/{path}", handler.handleUpdateContent).Methods("POST")

	return handler
}

func NewUsers(log *zap.Logger, mon *monkit.Scope, service UsersService, router *mux.Router) *UsersHandler {
	handler := &UsersHandler{
		log:     log,
		mon:     mon,
		service: service,
	}

	usersRouter := router.PathPrefix("/api/v0/users").Subrouter()
	usersRouter.HandleFunc("/", handler.handleGet).Methods("GET")
	usersRouter.HandleFunc("/", handler.handleCreate).Methods("POST")
	usersRouter.HandleFunc("/age", handler.handleGetAge).Methods("GET")

	return handler
}

func NewProjects(log *zap.Logger, mon *monkit.Scope, service ProjectsService, router *mux.Router) *ProjectsHandler {
	handler := &ProjectsHandler{
		log:     log,
		mon:     mon,
		service: service,
	}

	projectsRouter := router.PathPrefix("/api/v0/projects").Subrouter()
	projectsRouter.HandleFunc("/", handler.handleCreateProject).Methods("POST")

	return handler
}

func (h *DocumentsHandler) handleGet(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	retVal, httpErr := h.service.Get(ctx)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json Get response", zap.Error(ErrDocsAPI.Wrap(err)))
	}
}

func (h *DocumentsHandler) handleGetOne(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	path, ok := mux.Vars(r)["path"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing path route param"))
		return
	}

	ctx, err = h.auth.IsAuthenticated(ctx, r, true, true)
	if err != nil {
		h.auth.RemoveAuthCookie(w)
		api.ServeError(h.log, w, http.StatusUnauthorized, err)
		return
	}

	retVal, httpErr := h.service.GetOne(ctx, path)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GetOne response", zap.Error(ErrDocsAPI.Wrap(err)))
	}
}

func (h *DocumentsHandler) handleGetTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	path, ok := mux.Vars(r)["path"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing path route param"))
		return
	}

	tagName, ok := mux.Vars(r)["tagName"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing tagName route param"))
		return
	}

	ctx, err = h.auth.IsAuthenticated(ctx, r, true, true)
	if err != nil {
		h.auth.RemoveAuthCookie(w)
		api.ServeError(h.log, w, http.StatusUnauthorized, err)
		return
	}

	retVal, httpErr := h.service.GetTag(ctx, path, tagName)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GetTag response", zap.Error(ErrDocsAPI.Wrap(err)))
	}
}

func (h *DocumentsHandler) handleGetVersions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	path, ok := mux.Vars(r)["path"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing path route param"))
		return
	}

	ctx, err = h.auth.IsAuthenticated(ctx, r, true, true)
	if err != nil {
		h.auth.RemoveAuthCookie(w)
		api.ServeError(h.log, w, http.StatusUnauthorized, err)
		return
	}

	retVal, httpErr := h.service.GetVersions(ctx, path)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GetVersions response", zap.Error(ErrDocsAPI.Wrap(err)))
	}
}

func (h *DocumentsHandler) handleUpdateContent(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	idParam := r.URL.Query().Get("id")
	if idParam == "" {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("parameter 'id' can't be empty"))
		return
	}

	id, err := uuid.FromString(idParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	dateParam := r.URL.Query().Get("date")
	if dateParam == "" {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("parameter 'date' can't be empty"))
		return
	}

	date, err := time.Parse(dateLayout, dateParam)
	if err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	path, ok := mux.Vars(r)["path"]
	if !ok {
		api.ServeError(h.log, w, http.StatusBadRequest, errs.New("missing path route param"))
		return
	}

	payload := myapi.NewDocument{}
	if err = json.NewDecoder(r.Body).Decode(&payload); err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	ctx, err = h.auth.IsAuthenticated(ctx, r, true, true)
	if err != nil {
		h.auth.RemoveAuthCookie(w)
		api.ServeError(h.log, w, http.StatusUnauthorized, err)
		return
	}

	retVal, httpErr := h.service.UpdateContent(ctx, path, id, date, payload)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json UpdateContent response", zap.Error(ErrDocsAPI.Wrap(err)))
	}
}

func (h *UsersHandler) handleGet(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	retVal, httpErr := h.service.Get(ctx)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json Get response", zap.Error(ErrUsersAPI.Wrap(err)))
	}
}

func (h *UsersHandler) handleCreate(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	payload := []myapi.User{}
	if err = json.NewDecoder(r.Body).Decode(&payload); err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	httpErr := h.service.Create(ctx, payload)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
	}
}

func (h *UsersHandler) handleGetAge(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	retVal, httpErr := h.service.GetAge(ctx)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json GetAge response", zap.Error(ErrUsersAPI.Wrap(err)))
	}
}

func (h *ProjectsHandler) handleCreateProject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	var err error
	defer h.mon.Task()(&ctx)(&err)

	w.Header().Set("Content-Type", "application/json")

	payload := Project{}
	if err = json.NewDecoder(r.Body).Decode(&payload); err != nil {
		api.ServeError(h.log, w, http.StatusBadRequest, err)
		return
	}

	retVal, httpErr := h.service.CreateProject(ctx, payload)
	if httpErr.Err != nil {
		api.ServeError(h.log, w, httpErr.Status, httpErr.Err)
		return
	}

	err = json.NewEncoder(w).Encode(retVal)
	if err != nil {
		h.log.Debug("failed to write json CreateProject response", zap.Error(ErrProjectsAPI.Wrap(err)))
	}
}
